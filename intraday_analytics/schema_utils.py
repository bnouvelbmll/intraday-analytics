import polars as pl
from typing import List, Dict
from .configuration import AnalyticsConfig
from .analytics.l2 import L2AnalyticsLast, L2AnalyticsTW
from .analytics.l3 import L3Analytics
from .analytics.trade import TradeAnalytics
from .analytics.execution import ExecutionAnalytics
from .analytics.dense import DenseAnalytics


def get_output_schema(config: AnalyticsConfig) -> Dict[str, List[str]]:
    """
    Runs a dummy pipeline to determine the output schema (column names)
    generated by the provided configuration.

    Args:
        config: The AnalyticsConfig object.

    Returns:
        A dictionary mapping module names ('l2', 'l3', 'trade', 'execution')
        to a list of output column names.
    """

    # 1. Define Dummy Schemas (Minimal required columns)
    # These schemas must match what the analytics classes expect as input.

    # Common columns
    common_cols = {
        "ListingId": pl.Int64,
        "TimeBucket": pl.Datetime("ns"),
        "MIC": pl.Utf8,
        "Ticker": pl.Utf8,
        "CurrencyCode": pl.Utf8,
        "MarketState": pl.Utf8,
        "EventTimestamp": pl.Datetime("ns"),
        "DT": pl.Int64,  # Duration for TWA
    }

    # L2 Schema
    l2_schema = {**common_cols}
    # Add Bid/Ask Price/Qty/Orders for N levels (assuming max 100 for safety in dummy)
    for i in range(1, 101):
        l2_schema[f"BidPrice{i}"] = pl.Float64
        l2_schema[f"AskPrice{i}"] = pl.Float64
        l2_schema[f"BidQuantity{i}"] = pl.Float64
        l2_schema[f"AskQuantity{i}"] = pl.Float64
        l2_schema[f"BidNumOrders{i}"] = pl.Int64
        l2_schema[f"AskNumOrders{i}"] = pl.Int64

    # Trades Schema
    trades_schema = {
        **common_cols,
        "TradeDate": pl.Date,
        "Price": pl.Float64,
        "LocalPrice": pl.Float64,
        "Size": pl.Float64,
        "AggressorSide": pl.Int64,  # 1=Buy, 2=Sell
        "Classification": pl.Utf8,  # LIT_CONTINUOUS, etc.
        "BMLLTradeType": pl.Utf8,  # LIT, DARK
        "BMLLParticipantType": pl.Utf8,  # RETAIL, etc.
        "TradeNotionalEUR": pl.Float64,
        "TradeNotionalUSD": pl.Float64,
        "PricePoint": pl.Float64,
        # New columns for advanced metrics
        "PreTradeMid": pl.Float64,
        "MidPrice": pl.Float64,
        "PostTradeMidAtPrimary": pl.Float64,
        "PostTradeMid": pl.Float64,
        "BestBidPrice": pl.Float64,
        "BestAskPrice": pl.Float64,
        "BestBidPriceAtVenue": pl.Float64,
        "BestAskPriceAtVenue": pl.Float64,
        "BestBidPriceAtPrimary": pl.Float64,
        "BestAskPriceAtPrimary": pl.Float64,
        "PricePointAtVenue": pl.Float64,
        "PricePointAtPrimary": pl.Float64,
        "PreTradeElapsedTimeChg": pl.Float64,
        "PostTradeElapsedTimeChg": pl.Float64,
        "PreTradeElapsedTimeChgAtPrimary": pl.Float64,
        "PostTradeElapsedTimeChgAtPrimary": pl.Float64,
        "NegotiatedTrade": pl.Utf8,
        "LotType": pl.Utf8,
        "IsBlock": pl.Utf8,
        "CrossingTrade": pl.Utf8,
        "AlgorithmicTrade": pl.Utf8,
    }

    # L3 Schema
    l3_schema = {
        **common_cols,
        "LobAction": pl.Int64,  # 2=Insert, 3=Remove, 4=Update, 1=Exec
        "Side": pl.Int64,  # 1=Bid, 2=Ask
        "Size": pl.Float64,
        "OldSize": pl.Float64,
        "Price": pl.Float64,
        "OldPrice": pl.Float64,
        "ExecutionSize": pl.Float64,
        "ExecutionPrice": pl.Float64,
        "OrderID": pl.Int64,
        "SizeAhead": pl.Float64,
    }

    # 2. Create Dummy LazyFrames
    l2_dummy = pl.LazyFrame(schema=l2_schema)
    trades_dummy = pl.LazyFrame(schema=trades_schema)
    l3_dummy = pl.LazyFrame(schema=l3_schema)

    # MarketState dummy (needed for Dense)
    marketstate_dummy = pl.LazyFrame(
        schema={
            "ListingId": pl.Int64,
            "MarketState": pl.Utf8,
            "EventTimestamp": pl.Datetime("ns"),
        }
    )

    # 3. Instantiate and Compute
    output_columns = {}

    # --- L2 ---
    try:
        # L2 Last
        l2_last = L2AnalyticsLast(config.l2_analytics)
        l2_last.l2 = l2_dummy
        l2_last_df = l2_last.compute()
        output_columns["l2_last"] = l2_last_df.collect_schema().names()

        # L2 TW
        l2_tw = L2AnalyticsTW(config.l2_analytics)
        # BaseTWAnalytics expects .tw_analytics to be called by compute() or similar wrapper
        # But here we can call tw_analytics directly if we mock the input
        # The BaseTWAnalytics structure is a bit complex (resampling),
        # but L2AnalyticsTW.tw_analytics takes a frame and returns metrics.
        # We need to simulate the 'resampled' frame which has 'DT'
        l2_tw_df = l2_tw.tw_analytics(l2_dummy)
        output_columns["l2_tw"] = l2_tw_df.collect_schema().names()
    except Exception as e:
        output_columns["l2_error"] = [str(e)]

    # --- Trade ---
    try:
        trade_analytics = TradeAnalytics(config.trade_analytics)
        trade_analytics.trades = trades_dummy
        trade_df = trade_analytics.compute()
        output_columns["trade"] = trade_df.collect_schema().names()
    except Exception as e:
        output_columns["trade_error"] = [str(e)]

    # --- L3 ---
    try:
        l3_analytics = L3Analytics(config.l3_analytics)
        l3_analytics.l3 = l3_dummy
        l3_df = l3_analytics.compute()
        output_columns["l3"] = l3_df.collect_schema().names()
    except Exception as e:
        output_columns["l3_error"] = [str(e)]

    # --- Execution ---
    try:
        exec_analytics = ExecutionAnalytics(config.execution_analytics)
        exec_analytics.l3 = l3_dummy
        exec_analytics.trades = trades_dummy
        exec_df = exec_analytics.compute()
        output_columns["execution"] = exec_df.collect_schema().names()
    except Exception as e:
        output_columns["execution_error"] = [str(e)]

    return output_columns
